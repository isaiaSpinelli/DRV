# Laboratoire 2 DRV
Spinelli isaia
09.10.19

lien : http://reds-calculator.einet.ad.eivd.ch/drv_2019/

Remarque: Le code a été écrit de manière propre à partir de l'exercice 5. Je m'en excuse d'avance et espère que vous n'y prendrez pas compte.


## Téléchargement du noyau Linux et ajout des modules pour le User-space I/O

Commandes :

 - **git clone https://github.com/altera-opensource/linux-socfpga.git**
 - **cd linux-socfpga**
 - **git checkout socfpga-4.14.130-ltsi**

configuration :
**make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- socfpga_defconfig**
architecure: arm
tool chain : arm-linux-gnueabihf
board : socfpga_defconfig
Cela permet de compiler le noyau avec toutes les configurations correspendontes à notre matériel.

**grep UIO .config** permet de savoir si les userspace drivers sont actifs.
(UIO = Userspace I/O, vous trouvez l’howto officiel ici: https://www.kernel.org/doc/html/v4.14/driver-api/uio-howto.html).

Compilation avec **modification de la configuration :**

**make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig**

1. / UIO 	-> ajouter en module "Userspace I/O platform driver with generic IRQ handling"
2. / LBDAF -> activer "Support for large (2TB+) block devices and files"
3. exit and save


Il faut ensuite **modifier le device tree** pour qu’on puisse gérer les boutons avec le UIO driver. (save l'ancien .dts)
arch/arm/boot/dts/socfpga_cyclone5_sockit.dts-> ajouter :


    drv-btn {
      compatible = "drv-btn";
      reg = <0xFF200000 0x1000>;
      interrupts = <0 41 1>;
      interrupt-parent = <&intc>;
    };

On indique l'adresse du registre et sa taille ainsi que les numéros d'interruptions.

**compiler le noyau, les modules, et le device tree.**
![image](./img/cmd_compile_noyau_modules_dt.png)

Avertissement : le nom du répertoire source dans la dernière commande pourrait changer!! (ajout de sudo)

Ces commandes permettent de compiler le noyau, les modules et le device tree. Ensuite, copie les anciens fichiers pour les sauvgarder et place le nouveau noyau et dtb dans le dossier **/var/lib/tftpboot/** afin de les deployer sur la carte. Finalement, place les modules précèdemment compilés dans **/export/drv/**.

Finalement, après avoir boot sur la carte :
- cd /lib/modules
- rm * -rf
- mv /home/root/drv/4.14.130-ltsi-13527-g567dd6b26fcf-dirty/ .

après redemarrage, il faut verifier que les drivers user-space soient disponible en modules avec :

**zcat /proc/config.gz | grep UIO**

## Exercice 1

Afin de rechercher et analyser rapidement dans les configurations, j'utilise une interface qui me permet de facilement me balader dans les configurations. Il est possible d'avoir une interface pour configurer le noyau linux de plusieurs manière (make menuconfig ou xconfig).
Voici une liste des options principales configurable pour le noyaux linux :

- configurations général (IRQ,CPU/Task time, RCU,Performance du noyau, GCC,...)
- GCOV based kernel profiling (outil d'analyse de couverture de code )
- type de partitions
- Ordonnacneurs
- Bus options
- Boot options
- CPU Power management (ACPI / SFI / CPU Frequency scaling / idle PM support)
- Network
- CAN
- Device Drivers
- Firmware
- GPIO
- Block layer (tout ce qui ne travail pas par octet)
- Loadable module support
- Kernel hacking (printk/dmwesg/compiler/debug/runtime testing )
- Hardware I/O
- WathDog
- DMA / Timers / random memoire / MTRR /... (Processor type and features)
- Clock
- ADC
- Sensors
- File system
- Securité
- Cryptographic API
- Virtualization
- Library routines

Voici les desciprtions plus détaillées des sections demandées :

CPU power management :

GPIO support :

Block layer :

Kernel hacking :


## Exercice 2
Il a fallu écrire un logiciel user-space qui affiche sur l’écran un message lorsque l’utilisateur appuie sur le bouton KEY3. Ce logiciel est en annexe au nom de Ex2.c.

Afin de tester le fonctionnement du programme, il faut commencer par le compiler avec la toolchain suivante :arm-linux-gnueabihf-gcc.
Ensuite, il faut placer l'executable sur la carte (via /export/drv) puis l'executer avec "./".

Je pense que la différence avec l'utilisation de mmap() et des UIO permet de limiter l'accès à la memoire grâce à la descprition faite dans la dts. De plus, je crois qu'il y a la possibilité de recevoir des interruptions.


## Exercice 3

### drivers user-space

#### Avantages
- Rapide car moins de commutations de contexte utilisateur-noyau.
- Pas de plantage du système.
- Accès à pleins de bibliothèques donc surement plus simple à coder.
- Facilement déboguer avec des outils
- pour


#### Désavantages
- Presque tous sont basés sur du polling.
- Fait sens seulement quand tous les clients sont dans l'espace utilisateur.
swap



En bref je dirais qu'il faut surtout prendre en compte pour quelle matériels et client nous voulons faire le driver.


## Exercice 4

Pour commencer, il faut enlever "uio_pdrv_genirq" de la mémoire et le charger à nouveau avec le bon id :

modprobe -r uio_pdrv_genirq; modprobe uio_pdrv_genirq of_id="drv-btn"

Le code est en annexe (Ex4.c)

## Exercice 5

watch -n1 "cat /proc/interrupts"

## Exercice 6
read :
poll : permet beaucoup plus de possibilité, timeout en ms, le multiplexage, des prioritée,...
select :



Remarque: Afin  d'être le plus générique possible dans le code, je pense qu'il serait preferable de lire dans /sys/class/uio/uio0/device/uio/uio0/maps afin de récupérer les informations du device de facon sûr et générique.
![image](./img/info-device.png)
