# Laboratoire 2 DRV
Spinelli isaia
09.10.19

lien : http://reds-calculator.einet.ad.eivd.ch/drv_2019/


## Téléchargement du noyau Linux et ajout des modules pour le User-space I/O

Commandes :

 - **git clone https://github.com/altera-opensource/linux-socfpga.git**
 - **cd linux-socfpga**
 - **git checkout socfpga-4.14.130-ltsi**

configuration :
**make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- socfpga_defconfig**
architecure: arm
tool chain : arm-linux-gnueabihf
board : socfpga_defconfig
Cela permet de compiler le noyau avec toutes les configurations correspendontes à notre matériel.

**grep UIO .config** permet de savoir si les userspace drivers sont actifs.
(UIO = Userspace I/O, vous trouvez l’howto officiel ici: https://www.kernel.org/doc/html/v4.14/driver-api/uio-howto.html).

Compilation avec **modification de la configuration :**

**make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig**

/ UIO 	-> ajouter en module "Userspace I/O platform driver with generic IRQ handling"
/ LBDAF -> activer "Support for large (2TB+) block devices and files"
exit and save


Il faut ensuite **modifier le device tree** pour qu’on puisse gérer les boutons avec le UIO driver. (save l'ancien .dts)
arch/arm/boot/dts/socfpga_cyclone5_sockit.dts-> ajouter :


    drv-btn {
      compatible = "drv-btn";
      reg = <0xFF200000 0x1000>;
      interrupts = <0 41 1>;
      interrupt-parent = <&intc>;
    };

On indique l'adresse du registre et sa taille ainsi que les numéros d'interruptions.

**compiler le noyau, les modules, et le device tree.**
![image](./img/cmd_compile_noyau_modules_dt.png)

Avertissement : le nom du répertoire source dans la dernière commande pourrait changer!! (ajout de sudo)

Ces commandes permettent de compiler le noyau, les modules et le device tree. Ensuite, copie les anciens fichiers pour les sauvgarder et place le nouveau noyau et dtb dans le dossier **/var/lib/tftpboot/** afin de les deployer sur la carte. Finalement, place les modules précèdemment compilés dans **/export/drv/**.

Finalement, après avoir boot sur la carte :
- cd /lib/modules
- rm * -rf
- mv /home/root/drv/4.14.130-ltsi-13527-g567dd6b26fcf-dirty/ .

après redemarrage, il faut verifier que les drivers user-space soient disponible en modules avec :
**zcat /proc/config.gz | grep UIO**

## Exercice 1

Afin de rechercher et analyser rapidement dans les configurations, j'utilise **cat .config | grep -n ""** pour avoir les ligne qui m'interesse et ensuite j'ouvre le .config avec **less** et avec la commande **{line}g** je saute directement à la ligne souhaitée. **/search**->Search forward  **?search**->Search backward

Exemple pour "CPU power management":
![image](/img/search_cpu.png)
**less .config**
:**612g**

- configurations général
- IRQ
- Timers
- CPU/Task time
- RCU
- Performance du noyau
- GCOV based kernel profiling (outil d'analyse de couverture de code )
- type de partitions
- Ordonnacneurs
- Bus
- Boot options
- CPU Power management
- Network
- CAN
- Device Drivers
- Firmware
- GPIO
- Block layer (tout ce qui ne travail pas par octet)
- Kernel hacking (printk/dmwesg/compiler/debug )
- Hardware I/O
- WathDog
- DMA
- Clock
- ADC
- Sensors
- File system
- Securité
- Cryptographic API
- Virtualization
- Library routines

## Exercice 2
Il a fallu écrire un logiciel user-space qui affiche sur l’écran un message lorsque l’utilisateur appuie sur le bouton KEY3. Ce logiciel est en annexe au nom de Ex2.c.

Afin de tester le fonctionnement du programme, il faut commencer par le compiler avec la toolchain suivante :arm-linux-gnueabihf-gcc.
Ensuite, il faut placer l'executable sur la carte (via /export/drv) puis l'executer avec "./".

Je pense que la différence avec l'utilisation de mmap() et des UIO permet de limiter l'accès à la memoire grâce à la descprition faite dans la dts. De plus, je crois qu'il y a la possibilité de recevoir des interruptions.


## Exercice 3

### drivers user-space

#### Avantages
Rapide car moins de commutations de contexte utilisateur-noyau.
Pas de plantage du système.
Accès à pleins de bibliothèques donc surement plus simple à coder.
Facilement déboguer avec des outils

#### Désavantages
Presque tous sont basés sur du polling.
Fait sens seulement quand tous les clients sont dans l'espace utilisateur.

En bref je dirais qu'il faut surtout prendre en compte pour quelle matériels et client nous voulons faire le driver.


## Exercice 4


if ( (fd = open("/dev/uio0",O_RDWR)) < 0 ) {

if ( (seg = (vuint *) mmap(0, getpagesize(), PROT_READ|PROT_WRITE, MAP_SHARED, fd, (off_t)0)) == NULL){


## Exercice 5

watch -n1 "cat /proc/interrupts"

## Exercice 6
poll : permet beaucoup plus de possibilité, timeout en ms, le multiplexage, des prioritée,...
select :
